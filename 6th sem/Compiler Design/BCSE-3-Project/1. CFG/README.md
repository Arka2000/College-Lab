#Part - I 
		    Construct a CFG for a language 
---------------------------------------------------------

## Introduction
------------------------------
Before going to the rules and eloborate details of making construction, first we 
should know what is CFG and what is the purpose of doing this.
A context-free grammar (CFG) is a set of recursive rewriting rules (or productions) used to generate patterns of strings.

A CFG consists of the following components:

  -->A set of terminal symbols, which are the characters of the alphabet that appear in the strings generated by the grammar.
 -->A set of nonterminal symbols, which are placeholders for patterns of terminal symbols that can be generated by the nonterminal symbols.
 -->A set of productions, which are rules for replacing (or rewriting) nonterminal symbols (on the left side of the production) in a string with other nonterminal or terminal symbols (on the right side of the production).
 -->A start symbol, which is a special nonterminal symbol that appears in the initial string generated by the grammar.

## Why CFG and why is it so important ?
----------------------------------------------------
A CFG takes the input and creates a well structured representation of it. By the way, the context free part is important, because it is the type of language that imposes structure. For well known, parse tree is generated.

From the [ source : https://en.wikipedia.org/wiki/Chomsky_hierarchy ], 
Regular expressions don’t impose any structure. A regular expression language does not break things down into non-terminals, in particular not into non-terminals that can nest. Captures and backreferences impose some minimal structure, but again don’t deal with nesting the way that context free grammars do. That is why RE is type-0 level while CFG is more powerful than RE and hence type-1 level .

It is the allowing of (direct and indirect) recursive rules for non-terminals (that aren’t strictly left or right recursive) that give context-free grammars this power.

## Rules and Regulations
---------------------------------------------

The start symbol begins with <program> as an initial stage.
Then, start along with declaration list and statement list. Where, declaration list means the program that have been declared with a certain variables or constant. 
And, the statement list means the programs that may have been assigned / loops statement and others.

To generate a string of terminal symbols from a CFG, we:

Begin with a string consisting of the start symbol.
Apply one of the productions with the start symbol on the left hand size, replacing the start symbol with the right hand side of the production;
Repeat the process of selecting non-terminal symbols in the string, and replacing them with the right hand side of some corresponding production, until all non-terminals have been replaced by terminal symbols.

The whole constructed CFG are written in the short form manner. 

## Designing the grammer and its production
------------------------------------------------------------------------

Set of Terminals :
	main
 	int 
 	if 
 	else
 	return 
 	+ 
 	- 
 	* 
 	/ 
 	= 
 	( 
 	) 
 	{ 
 	} 
 	id 
 	digit 
 	; 
 	$

 Set of Non-terminals 
 -----
 	<program> <main function> <return type> <variable type> <compound statement> <statement sequence> <statement> <statement recursion> <definition statement> <assignment> <assignment statement> <conditional statement> <Boolean expression Formula> <expression> <term> <term recursion> <factorial> <factorial recursion> <relational operator> <identifier> <constant without sign>

-----------------------------------------
Grammatical production Rules 
----*****************************--------------------------
Non-terminal 								Production
------------------------------------------------------------------------------------------------
program							<program> ::= <main function> $
main_fun						<main function> ::= <return type> main () <compound statement>
return_type						<return type> ::= <variable type>
var_type						<variable type> ::= int
struct_statement				<compound statement> ::= {<statement sequence>}
statements_list					<statement sequence> ::= <statement> <statement recursion> | ε
statement						<statement> ::= <definition statement> | <assignment statement> |									<conditional statement> | <compound statement> | return<                                                                                  expression>;
statements_recursive	        <statement recursion> ::= <statement> <statement recursion> | ε
define_statement	            <definition statement> ::= <variable type> <identifier> <assign                                 initial value>;

assign_default	                <assign initial value> ::= = <expression> | ε
assign_statement	            <assignment statement> ::= <identifier> = <expression>;
condition_statement	            <conditional statement> ::= if (<boolean expression>) <compound 
	                           statement> else  <compound statement>
bool_expression	                <boolean expression> ::= <expression> <relational operator> <                                                          expression>
expression	                    <expression> ::= <item> <item recursion>
item	                        <term> ::= <factor> <factor recursion>
items_recursive	                <item recursion> ::= + <item> <item recursion> |-<item> <item                                  recursion> | ε

factor_recursive	            <factor Recursion> ::= * <factor> <factor Recursion> | / <factor>                                       <factor Recursion> | ε
factor	                        <factor> ::= <identifier> | <unsigned constant> | (<expression>)
relation_operator	            <relational operator> ::= equal | less | less_equal | great_than |                                                        great_equal | not_equal
identifier	                     <identifier> ::= id
unsigned_const	                 <unsigned constant> ::= digit


## Lists of Short Names and its meaning 
---------------------------------------------
1> <program> 		:= Start symbol 
2> <rtype> 	 		:= Return type, means the function that returns the value 
3> <dec_list> 		:= Declaration list, where to declare the variables as well as constant 
4> <stmt_list> 		:= Statement list, a list of statements are provided for assignment or for 								other purpose like for loop, if statement, etc.
5> <stmt>			:=
6> <dtype> 			:= Data type, means the type of data such as int, char, float, double, etc.
7> <id_list>		:= A list of identifiers
8> <id>				:= May have variable or char or strings 
9> <exp>			:= Expression , such as multiplication, division , addition, substraction , etc.
						Also can initialize variables 
10> <cndtn>			:= A state of condition (i <= 10 ) meaning, i should have be less than or equal 						to 10. This is called conditions. Mostly applicable in if statement, loop 							statement. 
11> <term>			:= Only addition and substaction specified
12> <factor> 		:= Only multiplication and divison specified
13> <relop> 		:= Relational operation such as < , > , <= , >= , == 

## Which sample language did CFG is constructed ?
------------------------------------------------------------------
Only test1.c is constructed in the form of CFG. It is provided in inside the sampleCode folder. 

